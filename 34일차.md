## 커리큘럼(12-30/변경)
```
01. Java
02. git
03. Database (v)
04. Jsp [Server]

05. 미니프로젝트 (3W)
06. HTML,CSS  
07. JS

08. SpringFramework , SrpingBoot
09. React JS [Front-end]
10. 중간프로젝트 (1M)
11. Linux 명령어
12. AWS 클라우드
13. DevOps - Docker
14. App - Android
15. 최종프로젝트 (1M)
```
---
# SQL
## 분석 함수


| 함수명 | 설명 |
|:-----:|:-----|
| RANK | 해당 값에 대한 우선순위를 결정(중복순위 계산) |
| DENSE_RANK | 해당 값에 대한 우선순위 결정(중복순위 계산 안함) |
| ROW_NUMBER | 조건을 만족하는 모든 행의 번호 제공 |

> + 순위 함수
> + ``RANK(), DENSE_RANK(), ROW_NUMBER()`` 함수는 ``OVER(순위 조건)``과 함께 사용
> ```
> SELECT FIRST_NAME,
>        SALARY,
>        RANK() OVER(ORDER BY SALARY DESC) 중복등수,
>        DENSE_RANK() OVER(ORDER BY SALARY DESC) 중복없는등수,
>        ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 일련번호,
>        ROW_NUM -- 정렬되면 순서가 바뀜
> FROM EMPLOYEES;
>
> ```

> ### RANK
>> + 중복 순위 계산
>> + ex : 2등이 2명이면 다음 순위는 4등 
> ### DENSE_RANK
>> + 중복순위 계산하지 않음
>> + ex : 2등이 2명이더라도 다음 순위는 3등
> ### ROW_NUMBER
>> + 조건을 만족하는 모든 행의 번호 제공(일련번호 생성)



## 그룹 함수


| 함수 | 설명 |
|:-----:|:-----|
| AVG(n) | NULL값을 무시한 n의 평균 |
| SUM(n) | Null값을 무시한 n의 합계 |
| MIN(expr) | Null값을 무시한 expr 최솟값 |
| MAX(expr) | Null값을 무시한 expr의 최댓값 | 
| COUNT({*}expr) | 행의 수, expr은 Null값을 제외하고 계산. *를 사용해 중복되거나 Null인 행등을 포함하여 모든 행 계산 |

> + 행에 대한 기초통계값
> + 전부 NULL이 아닌 데이터에 대해서 통계를 구함
> `` SELECT SUM(SALARY), AVG(SALARY), MAX(SALARY), MIN(SALARY), COUNT(SALARY) FROM EMPLOYEES; ``

> + ``MIN,MAX 함수``는 **날짜, 문자열에도 적용**됨
>> ```
>> SELECT MIN(HIRE_DATE), MAX(HIRE_DATE), MIN(FIRST_NAME), MAX(FIRST_NAME) FROM EMPLOYEES;
>> ```

> + COUNT함수의 2가지 사용법
>> 1. NULL이 아닌 데이터에 대해서 집계(기본)
>>> ```
>>> SELECT COUNT(COMMISSION_PCT) FROM EMPLOYEES; --35 : NULL이 아닌 데이터에 대해서 집계
>>> ```
>> 2. NULL을 포함한 전체 행수
>>> ```
>>> SELECT COUNT(*) FROM EMPLOYEES; -- 107 : NULL값을 포함한 전체 행수
>>> ```

> + **그룹함수는 일반컬럼과 동시에 사용 불가능**
>> ```
>> SELECT FIRST_NAME, AVG(SALARY) FROM EMPLOYEES; -- 오류, FIRST_NAME 제외시 작동
>> ```
> + **그룹함수 뒤에 OVER(**)**를 붙이면 전체행이 출력되고, **그룹함수 사용 가능**
>> ```
>> SELECT FIRST_NAME, AVG(SALARY) OVER(), COUNT(*) OVER FROM EMPLOYEES;
>> ```


## GROUP BY
> ```
> SELECT column, group_function(column)
> FROM table
> [WHERE condition(s)]
> [GROUP BY group_by_expression]
> [ORDER BY {column|expr, ...} [[ASC]|DESC]];
> ```

> + 컬럼기준으로 **그룹화**
>> ```
>> SELECT DEPARTMENT_ID FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
>> ```
> 
> + 그룹함수를 함께 사용 가능
>> ```
>> SELECT DEPARTMENT_ID,SUM(SALARY), AVG(SALARY), MIN(SALARY), MAX(SALARY), COUNT(*)
>> FROM EMPLOYEES GROUP BY DEPARTMENT_ID ;
>> ```
>> 
>> + 주의할 점 : **GROUP BY 절을 사용**했다면 **GROUP화했던 컬럼만 SELECT절에서 쓸 수 있음**
>>> ```
>>> SELECT DEPARTMENT_ID,FIRST_NAME FROM EMPLOYEES GROUP BY DEPARTMENT_ID; -- 오류
>>> ```
> 
> + 2개 이상의 그룹화
>> ```
>> SELECT DEPARTMENT_ID, JOB_ID,AVG(SALARY)
>> FROM EMPLOYEES
>> GROUP BY DEPARTMENT_ID, JOB_ID
>> ORDER BY DEPARTMENT_ID;
>> ```
>>
>> + COUNT(*) OVER() 총 행의 수를 출력
>>> ```
>>> SELECT DEPARTMENT_ID, JOB_ID,COUNT(*),COUNT(*) OVER() AS 전체행수
>>> FROM EMPLOYEES
>>> GROUP BY DEPARTMENT_ID, JOB_ID
>>> ORDER BY DEPARTMENT_ID;
>>> ```
> 
> + **WHERE절에는 GROUP의 조건을 넣을 수 없음**
> + GROUPY BY절과 함께 쓰인 WHERE절에는 그룹의 조건 외에는 사용 가능
>> + **GROUP의 조건**은 **HAVING**절에 넣어야 함 
>> ```
>> SELECT DEPARTMENT_ID, SUM(SALARY)
>> FROM EMPLOYEES
>> WHERE SUM(SALARY) >= 50 -- 오류 : GROUP BY조건을 쓰는 곳은 HAVING이 따로 있음
>> GROUP BY DEPARTMENT_ID;
>> ```
> 
> + GROUP BY 절은 WHERE절 다음 ORDER 절 사이에 쓰임



## HAVING
> ```
> SELECT column, group_function(column)
> FROM table
> [WHERE condition(s)]
> [GROUP BY group_by_expression]
> [HAVING group_condition]
> [ORDER BY {column|expr [[ASC]|DESC], ...}];
> ```

> + **GROUP BY절의 조건**을 작성하는 곳
>> ```
>> SELECT DEPARTMENT_ID, AVG(SALARY),COUNT(*)
>> FROM EMPLOYEES
>> GROUP BY DEPARTMENT_ID
>> HAVING AVG(SALARY)>=5000 AND COUNT(*)>=1;
>> ```
>>
>> + 예시>> ![ROLLUP함수](https://buly.kr/uTUCy2)
>>> ```
>>> -- 각  JOB_ID가 SA로 시작하는 직무별 급여 평균이 10000이 넘는 직무
>>> SELECT JOB_ID, AVG(SALARY)
>>> FROM EMPLOYEES
>>> WHERE JOB_ID LIKE 'SA%'
>>> GROUP BY JOB_ID
>>> HAVING AVG(SALARY)>=10000
>>> ORDER BY AVG(SALARY) DESC;
>>> ```



## ROLLUP,CUBE,GROUPING
> ### ROULLUP
>> + GROUP BY 절과 같이 사용되며, GROUP BY절에 의해서 그룹 지어진 집합 결과에 대해서 좀 더 상세한 정보를 반환하는 기능 수행
>> + 소계, 총계를 구할 수 있음
>> ![ROLLUP함수](https://buly.kr/uTUCy2)
> 
> ### CUBE
>> + 서브 그룹에 대한 Summary를 추출하는데 사용
>> ![CUBE함수](https://buly.kr/GkrgUSL)
>
> ### GROUPING