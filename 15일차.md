## 커리큘럼(12-30/변경)
```
01. Java (v)
02. git 
03. Database
04. Jsp [Server]

05. 미니프로젝트 (3W)
06. HTML,CSS  
07. JS

08. SpringFramework , SrpingBoot
09. React JS [Front-end]
10. 중간프로젝트 (1M)
11. Linux 명령어
12. AWS 클라우드
13. DevOps - Docker
14. App - Android
15. 최종프로젝트 (1M)
```
---

+ Java Debugging
	- breakpoint 설정
	- debug 실행(debug 아이콘)

### 배열 복사
#### 얕은 복사
- `객체의 참조(주소값)만 복사`해 원본 객체와 복사된 객체가 같은 인스턴스를 참조하도록 만듬.
- 복사된 객체는 원본 객체의 데이터를 수정할 수 있음
- 객체안에 참조하는 다른 객체가 있을 경우, 그 내부 객체들은 복사되지 않고 원본객체와 공유
```
  // 원본 배열 생성
    int[] arr1 = {1, 2, 3, 4, 5};
       
    // 얕은 복사: arr1 배열의 참조를 arr2에 복사
    int[] arr2 = arr1;  // 배열 참조만 복사

    // arr2의 첫 번째 원소를 수정
    arr2[0] = 10;

    // arr1도 영향을 받음
    System.out.println("arr1: " + arr1[0]);  // 10
    System.out.println("arr2: " + arr2[0]);  // 10
```

#### 깊은 복사
- 객체 자체 뿐만 아니라 객체가 참조하는 모든 객체까지 복사.
- 복사된 객체는 원본 객체와 독립적으로 존재
```
 	// 원본 배열 생성
    int[] arr1 = {1, 2, 3, 4, 5};
        
    // 깊은 복사: 새로운 배열을 생성하여 원소들을 복사
    int[] arr2 = new int[arr1.length];  // 새로운 배열 생성
    for (int i = 0; i < arr1.length; i++) {
        arr2[i] = arr1[i];  // 배열 원소를 복사
    }

    // arr2의 첫 번째 원소를 수정
    arr2[0] = 10;

    // arr1은 영향을 받지 않음
    System.out.println("arr1: " + arr1[0]);  // 1
    System.out.println("arr2: " + arr2[0]);  // 10
```

### 배열정렬(ArraySort)
#### - 선택정렬
- 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 원시적 방법
- 배열의 앞에서부터 정렬되어 가는 방식
- `매번 가장 작은것을 선택`
- 선택 정렬의 시간복잡도는 $$O(N^2)$$
```
	int[] arr = {5,23,1,43,200,100,40};


	//(1)
	for(int i=0;i<arr.length-1;i++) {
		for(int j=i+1;j<arr.length;j++) {
			if(arr[i]>arr[j]) {
				int temp=arr[i];
				arr[i]=arr[j];
				arr[j]=temp;
			}
		}
	}

	//(2)
	for(int i=0;i<arr.length-1;i++) {
		int min_index=i;
		for(int j=i+1;j<arr.length;j++) {
			if(arr[i]>arr[j]) {
				min_index=j;	
			}
		}
		int temp=arr[i];
		arr[i]=arr[min_index];
		arr[min_index]=temp;
	}
```

```
선택 정렬 과정 예시: 배열 [64, 25, 12, 22, 11]

1회전:
첫 번째 원소 64와 나머지 원소들(25, 12, 22, 11)을 비교
64와 11을 교환 → [11, 25, 12, 22, 64]

2회전:
두 번째 원소 25와 나머지 원소들(12, 22, 64)을 비교
25와 12를 교환 → [11, 12, 25, 22, 64]

3회전:
세 번째 원소 25와 나머지 원소들(22, 64)을 비교
25와 22를 교환 → [11, 12, 22, 25, 64]

4회전:
네 번째 원소 25와 64를 비교
변경 없음 → [11, 12, 22, 25, 64]
```

#### - 버블정렬
- 인전합 두 원소를 비교하여 순서를 교환 하는 방식
- `가장 큰 원소`가 배열의 가장 뒤로 정렬
- 배열의 뒤쪽부터 정렬되어 가는 방식
```
	for(int i=0;i<arr.length-1;i++) {
		for(int j=0;j<arr.length-1-i;j++) {
			if(arr[j]>arr[j+1]) {
				int temp = arr[j];
				arr[j]=arr[j+1];
				arr[j+1]=temp;
			}
		}
	}

```

```
예시 (오름차순 정렬): [5, 2, 9, 1, 5, 6]

1회전:
5 > 2 → 교환 → [2, 5, 9, 1, 5, 6]
5 < 9 → 그대로
9 > 1 → 교환 → [2, 5, 1, 9, 5, 6]
9 > 5 → 교환 → [2, 5, 1, 5, 9, 6]
9 > 6 → 교환 → [2, 5, 1, 5, 6, 9]

2회전:
2 < 5 → 그대로
5 > 1 → 교환 → [2, 1, 5, 5, 6, 9]
5 < 5 → 그대로
5 < 6 → 그대로

3회전 : 
2 > 1 → 교환 → [1, 2, 5, 5, 6, 9]
```