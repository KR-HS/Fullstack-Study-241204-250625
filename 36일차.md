## 커리큘럼(12-30/변경)
```
01. Java
02. git
03. Database (v)
04. Jsp [Server]

05. 미니프로젝트 (3W)
06. HTML,CSS  
07. JS

08. SpringFramework , SrpingBoot
09. React JS [Front-end]
10. 중간프로젝트 (1M)
11. Linux 명령어
12. AWS 클라우드
13. DevOps - Docker
14. App - Android
15. 최종프로젝트 (1M)
```
---
# SQL
## DML(Data Manipulation Language)
+ 데이터 베이스에 데이터를 **추가, 갱신 또는 삭제**할때 사용
> + DML 문장이 실행되는 경우 
>> + 새로운 행 추가(Insert)
>> + 기존의 행 변경(Update)
>> + 기존의 행 제거(Delete)

> + *트랜잭션(Transaction)
>> + 작업의 논리적인 단위 형태인 DML 문장의 모음

> ### INSERT
>> ```
>> INSERT INTO TABLE명 [(COLUMN1,COLUMN2,...)]
>> VALUES [(VALUE1,VALUE2,....)];
>> ```
>> + 각각의 열에 대한 값을 포함하는 새로운 행 삽입
>> + 테이블에 있는 열의 디폴트 순서로 값 나열
>> + INSERT 절에서 열을 선택적으로 나열
>> + 문자와 날짜 값은 단일 따옴표 내에 둠
>> 
>> ```
>> -- 1ST ( 컬럼을 정확히 일치시키는 경우)
>> INSERT INTO DEPARTMENTS VALUES(280,'DEVELOPER',NULL,1700);
>> 
>> -- 2ND( 컬럼을 지정해서 넣는 경우)
>> INSERT INTO DEPARTMENTS(DEPARTMENT_ID,DEPARTMENT_NAME,LOCATION_ID) VALUES(280,'DEVELOPER',1700);
>> INSERT INTO DEPARTMENTS(DEPARTMENT_ID,DEPARTMENT_NAME,LOCATION_ID,MANAGER_ID) VALUES(290,'DBA',1700,100);
>> ```
>>
>> + INSERT문의 서브쿼리리
>>> + VALUES 절을 사용하지 않음
>>> + 서브쿼리의 열 수와 INSERT 절의 열 수는 일치해야 함
>>> ```
>>> -- 1ST
>>> INSERT INTO EMPS (EMPLOYEE_ID,LAST_NAME,EMAIL,HIRE_DATE,JOB_ID)
>>> (SELECT EMPLOYEE_ID,LAST_NAME,EMAIL,HIRE_DATE,JOB_ID FROM EMPLOYEES WHERE JOB_ID LIKE '%MAN');
>>> 
>>> -- 2ND
>>> INSERT INTO EMPS (EMPLOYEE_ID, LAST_NAME,EMAIL,HIRE_DATE,JOB_ID)
>>> VALUES( (SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE FIRST_NAME='Lex'),'EXAMPLE','EXAMPLE',SYSDATE,'EXAMPLE');
>>> ```
>
> ### UPDATE
>> ```
>> UPDATE table명
>> SET column = value [, colum = value, ....]
>> [WHERE condition]; -- WHERE절이 없으면 모든 행에 대해서 UPDATE구문이 적용되기 때문에 조건설정이 필요
>> ```
>> 
>> + 기존의 행 갱신
>> + 하나 이상의 행을 갱신 가능
>> ```
>> UPDATE EMPS
>> SET FIRST_NAME='HONG', SALARY=3000, COMMISSION_PCT=0.1
>> WHERE EMPLOYEE_ID = 120;
>> ```
>> 
>> + UPDATE문의 서브쿼리
>>> ```
>>> -- UPDATE문의 서브쿼리
>>> UPDATE EMPS
>>> SET (MANAGER_ID,JOB_ID,SALARY) = (SELECT MANAGER_ID, JOB_ID, SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID=201)
>>> WHERE EMPLOYEE_ID = 120;
>>> ```
>
> ### DELETE
>> ```
>> DELETE FROM table명
>> [WHERE condition]; -- 조건 설정을 하지 않을 경우 모든 행 삭제
>> ```
>> 
>> + 테이블로부터 기존의 행 제거
>> + 참조 무결성 제약 조건에 주의해야 함
>> ```
>> DELETE FROM EMPS WHERE EMPLOYEE_ID=120;
>> ```
>>
>> + DELETE문의 서브쿼리
>>> ```
>>> DELETE FROM EMPS WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID=121);
>>> ```


> ### MERGE
>> ```
>> MERGE INTO table
>> USING (taget / view / subquery)
>> ON (join_condition)
>> WHEN MATCHED THEN
>> UPDATE SET column1=value1[,....]
>> WHEN NOT MATCHED THEN
>> INSERT (column_lists) VALUES (value_lists);
>> ```
>> 
>> + DB에 INSERT 또는 UPDATE할 때, 데이터가 존재하는지 여부를 체크하고 **존재하면 UPDATE**를 하고, **존재하지 않으면 INSERT**를 수행
>> 
>> ```
>> -- 1ST : : 동일한 테이블 구조를 가지고 있는 다른 테이블로부터 데이터를 옮길 떄 
>> MERGE INTO EMPS E1 -- MERGE를 시킬 타겟테이블
>> USING (SELECT * FROM EMPLOYEES WHERE JOB_ID LIKE '%MAN') E2 -- 병합할 테이블(서브쿼리)
>> ON (E1.EMPLOYEE_ID = E2.EMPLOYEE_ID) -- E1과 E2 데이터가 연결되는 조건
>> WHEN MATCHED THEN -- 일치할 때 수행할 작업
>>     UPDATE SET E1.SALARY=E2.SALARY, E1.COMMISSION_PCT = E2.COMMISSION_PCT
>> WHEN NOT MATCHED THEN -- 일치하지 않을 때 수행할 작업
>>     INSERT (EMPLOYEE_ID,LAST_NAME,EMAIL,HIRE_DATE,JOB_ID)
>>     VALUES (E2.EMPLOYEE_ID,E2.LAST_NAME,E2.EMAIL,E2.HIRE_DATE,E2.JOB_ID);
>> 
>> -- 2ND : MERGE문으로 직접 특정 데이터에 값을 넣고자 할 때 사용할 수 있음
>> MERGE INTO EMPS E1
>> USING DUAL
>> ON (E1.EMPLOYEE_ID = 200)
>> WHEN MATCHED THEN
>>     UPDATE SET E1.SALARY =10000,
>>                E1.HIRE_DATE = SYSDATE
>> WHEN NOT MATCHED THEN
>>     INSERT(LAST_NAME,EMAIL,HIRE_DATE,JOB_ID)
>>     VALUES('EXAMPLE','EXAMPLE',SYSDATE,'EXAMPLE');
>> ```


> ### CTAS(CREATE TABLE AS SELECT)
>> ``CREATE TABLE <talbe명> AS SELECT <statement>``
>> + 현재 있는 테이블과 같은 구조를 갖는 테이블을 생성
>> + CTAS 구문을 이요한 테이블 복제시 NOT NULL 제약조건을 제외한 다른 제약조건은 복사되지 않음
>>
>> ```
>> CREATE TABLE EMP1 AS (SELECT * FROM EMPLOYEES);
>> SELECT * FROM EMP1;
>> CREATE TABLE EMP2 AS (SELECT * FROM EMPLOYEES WHERE 1 =2 ); -- 테이블 구조만 복사
>> SELECT * FROM EMP2;
>> ```

---
## 트랜잭션(Transaction)
> + 논리적인 작업의 단위
> + 분리되어서는 안 될 작업의 단위
> + 트랜잭션의 시작은 실행 가능한 첫 번쨰 SQL문장이 실행 될 때 시작
> + COMMIT이나 ROLLBACK 문에 의해 명시적으로 종료하거나, DDL이나 DCL문장 실행으로 자동 커밋되어 종료될 수 있음

> + **트랜잭션 구문**
>> 
>> | 문장 | 설명 |
>> |:-----|:-----|
>> | COMMIT | 모든 미결정 데이터를 영구적으로 변경함으로서 현재 트랜잭션을 종료 |
>> | SAVEPOING savepoint_name | 현재 트랜잭션 내에 savepoint를 표시 |
>> | ROLLBACK [[TO \\[SAVEPOINT\\]] savepoint_name] | ROLLBACK은 모든 미결정 데이터 변경을 버림으로써 현재의 트랜잭션을 종료 | 

