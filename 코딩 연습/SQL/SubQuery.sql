-- 단일행 서브쿼리 : SELECT한 결과가 1행인 서브쿼리
-- 서브쿼리는 ()로 묶는다. 연산자보다는 오른쪽에 나옴

SELECT * 
FROM EMPLOYEES 
WHERE SALARY >= (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME= 'Nancy');

-- 직원번호가 103번인 사람과 동일한 직무를 가진사람

SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE EMPLOYEE_ID=103;

SELECT * 
FROM EMPLOYEES 
WHERE SALARY >= (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME= 'Nancy');
-- 주의할점 : 단일행 서브쿼리는 반드시 하나의 행을 리턴을 해야함
-- 서브쿼리가 반환하는 행이 여러행이라면, 다중행 연산자를 쓰면 됨
SELECT SALARY
FROM EMPLOYEES WHERE FIRST_NAME = 'David';

SELECT * FROM EMPLOYEES WHERE SALARY IN (SELECT SALARY
FROM EMPLOYEES WHERE FIRST_NAME = 'David');

-- 다중행 서브쿼리
-- > ANY: 최소값 4800 보다 큰 데이터
SELECT *
FROM EMPLOYEES
WHERE SALARY > ANY (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME='David');

-- < ANY : 최대값 9500 보다 작은 데이터
SELECT *
FROM EMPLOYEES
WHERE SALARY < ANY (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME='David');

-- > ALL : 최대값 9500보다 큰 데이터 
SELECT *
FROM EMPLOYEES
WHERE SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME='David');

-- < ALL : 최소값 4800보다 작은 데이터 
SELECT *
FROM EMPLOYEES
WHERE SALARY < ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME='David');

-- IN : 정확히 일치하는 데이터가 나옴
SELECT *
FROM EMPLOYEES
WHERE SALARY IN (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME='David');


-- 스칼라 서브쿼리 : SELECT절에 들어오는 서브쿼리로 조인을 대체할 수 있음

SELECT FIRST_NAME,
       (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) DEPARTMENT_NAME
FROM EMPLOYEES E;

-- 스칼라 쿼리는 한번에 하나의 컬럼을 가지고 옴. 많은 열을 가지고 올때는 가독성이 떨어질 수 있음
SELECT FIRST_NAME,
       (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID),
       (SELECT MANAGER_ID FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID)
FROM EMPLOYEES E;

-- 스칼라 쿼리는 다른 테이블의 1개의 컬럼만 가지고 올때 조인보다 유리할 수 있음
-- 회원별 JOBS 테이블의 TITLE을 가지고 오고, 부서테이블의 부서명을 조회
SELECT FIRST_NAME,
       (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) DEPARTMENT_NAME,
       (SELECT JOB_TITLE FROM JOBS J WHERE JOB_ID = E.JOB_ID) JOB_TITLE
FROM EMPLOYEES E;

-- JOIN구문으로
SELECT FIRST_NAME,
       DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

------------------------------------
-- 인라인뷰 : FROM절 하위에 서브쿼리가 들어감
-- SELECT절에서 만든 가상 컬럼에 대해서 조회를 해 나갈때 사용
SELECT *
FROM (SELECT *
      FROM (SELECT * 
            FROM EMPLOYEES)
);

-- ROWNUM은 조회된 순서에 대해서 번호가 붙기 때문에 ORDER BY를 쓰면 순서가 뒤바뀜
SELECT ROWNUM,
       EMPLOYEE_ID,
       FIRST_NAME,
       SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;

-- 인라인뷰
SELECT ROWNUM,
       EMPLOYEE_ID,
       FIRST_NAME,
       SALARY
FROM (SELECT *
      FROM EMPLOYEES
      ORDER BY SALARY DESC
      )
WHERE ROWNUM >10 AND ROWNUM <= 20; -- 10~20번째 데이터가 나와야하는데 , ROWNUM은 1부터 조회 가능

-- 인라인뷰로 FROM절에 필요한 컬럼을 가상의 컬럼으로 만들어놓고 조회
SELECT ROWNUM AS RN, FIRST_NAME || LAST_NAME NAME, SALARY
FROM (
       SELECT *
       FROM EMPLOYEES
       ORDER BY SALARY DESC
      ) A -- 테이블 앨리어스
WHERE RN>10 AND BR<=20;

-- 인라인뷰 EX
-- 근속년수 컬럼, COMMISSION이 더해진 급여 컬럼을 가상으로 만들어주고 조회
SELECT FIRST_NAME || LAST_NAME "이름",
       TRUNC((SYSDATE-HIRE_DATE)/365) 근속년수,
       SALARY + SALARY*NVL(COMMISSION_PCT,0) AS 급여       
FROM EMPLOYEES
ORDER BY 근속년수;